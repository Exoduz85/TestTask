#pragma kernel CSCreateSphere

#define PI 3.141592653589793238462643383279502884197 // approximation of PI with 39 decimals
#define MAX_SPHERE_THREADS 8 // optimal for 64 (8x8)

// buffers
RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<int> triangles;

// sphere settings
int sphereResolution;
int sphereVertexOffset;
int sphereTriangleOffset;
float sphereRadius;

// todo: add cone settings

[numthreads(MAX_SPHERE_THREADS,MAX_SPHERE_THREADS,1)]
void CSCreateSphere(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;

    if (x >= sphereResolution || y >= sphereResolution)
        return;

    uint index = y * sphereResolution + x;
    float u = (float)x / (sphereResolution - 1);
    float v = (float)y / (sphereResolution - 1);

    float theta = u * 2.0f * PI;
    float phi = v * PI;

    float3 pos;
    pos.x = sin(phi) * cos(theta);
    pos.y = cos(phi);
    pos.z = sin(phi) * sin(theta);

    pos *= sphereRadius;

    vertices[sphereVertexOffset + index] = pos;

    if (x < sphereResolution - 1 && y < sphereResolution - 1)
    {
        int i0 = index;
        int i1 = i0 + 1;
        int i2 = i0 + sphereResolution;
        int i3 = i2 + 1;

        int t = (y * (sphereResolution - 1) + x) * 6;

        triangles[sphereTriangleOffset + t + 0] = sphereVertexOffset + i0;
        triangles[sphereTriangleOffset + t + 1] = sphereVertexOffset + i2;
        triangles[sphereTriangleOffset + t + 2] = sphereVertexOffset + i1;

        triangles[sphereTriangleOffset + t + 3] = sphereVertexOffset + i1;
        triangles[sphereTriangleOffset + t + 4] = sphereVertexOffset + i2;
        triangles[sphereTriangleOffset + t + 5] = sphereVertexOffset + i3;
    }
}

// todo, add kernel for creation of cones with offsets from created spheres
